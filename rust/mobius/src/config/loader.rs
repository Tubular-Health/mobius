use std::env;
use std::fs;
use std::path::Path;

use crate::types::config::{JiraConfig, LoopConfig};
use crate::types::enums::{Backend, Model};

use super::error::ConfigError;

/// Read and parse config file, merging with defaults.
/// If the file doesn't exist, returns defaults.
pub fn read_config(config_path: &str) -> Result<LoopConfig, ConfigError> {
    let path = Path::new(config_path);

    if !path.exists() {
        return Ok(LoopConfig::default());
    }

    let content = fs::read_to_string(path)?;
    let parsed: LoopConfig = serde_yaml::from_str(&content)?;

    Ok(parsed)
}

/// Read config with environment variable overrides applied.
///
/// Supported environment variables:
/// - MOBIUS_BACKEND: Override backend (linear, jira, local)
/// - MOBIUS_DELAY_SECONDS: Override delay between iterations
/// - MOBIUS_MAX_ITERATIONS: Override max iterations
/// - MOBIUS_MODEL: Override AI model (opus, sonnet, haiku)
/// - MOBIUS_SANDBOX_ENABLED: Override sandbox setting (true/false)
/// - MOBIUS_CONTAINER: Override container name
pub fn read_config_with_env(config_path: &str) -> Result<LoopConfig, ConfigError> {
    let mut config = read_config(config_path)?;

    if let Ok(backend) = env::var("MOBIUS_BACKEND") {
        if let Ok(b) = backend.parse::<Backend>() {
            config.backend = b;
        }
    }

    if let Ok(delay) = env::var("MOBIUS_DELAY_SECONDS") {
        if let Ok(d) = delay.parse::<u32>() {
            config.execution.delay_seconds = d;
        }
    }

    if let Ok(max_iter) = env::var("MOBIUS_MAX_ITERATIONS") {
        if let Ok(m) = max_iter.parse::<u32>() {
            config.execution.max_iterations = m;
        }
    }

    if let Ok(model) = env::var("MOBIUS_MODEL") {
        if let Ok(m) = model.parse::<Model>() {
            config.execution.model = m;
        }
    }

    if let Ok(sandbox) = env::var("MOBIUS_SANDBOX_ENABLED") {
        match sandbox.to_lowercase().as_str() {
            "true" | "1" | "yes" => config.execution.sandbox = true,
            "false" | "0" | "no" => config.execution.sandbox = false,
            _ => {}
        }
    }

    if let Ok(container) = env::var("MOBIUS_CONTAINER") {
        if !container.is_empty() {
            config.execution.container_name = container;
        }
    }

    Ok(config)
}

/// Write config to file with header comments
pub fn write_config(config_path: &str, config: &LoopConfig) -> Result<(), ConfigError> {
    let path = Path::new(config_path);

    if let Some(dir) = path.parent() {
        if !dir.exists() {
            fs::create_dir_all(dir)?;
        }
    }

    let yaml = serde_yaml::to_string(config)?;
    let content = format!(
        "# Mobius Configuration\n\
         # Generated by 'mobius setup'\n\
         #\n\
         # Environment variables override these settings:\n\
         #   MOBIUS_BACKEND, MOBIUS_DELAY_SECONDS, etc.\n\
         \n\
         {yaml}"
    );

    fs::write(path, content)?;
    Ok(())
}

/// Check if config file exists
pub fn config_exists(config_path: &str) -> bool {
    Path::new(config_path).exists()
}

/// Validation result
pub struct ValidationResult {
    pub valid: bool,
    pub errors: Vec<String>,
}

/// Validate the full config structure
pub fn validate_config(config: &LoopConfig) -> ValidationResult {
    let mut errors = Vec::new();

    // Validate execution section
    if config.execution.delay_seconds > 3600 {
        errors.push("execution.delay_seconds must be reasonable (0-3600)".to_string());
    }

    if config.execution.max_iterations == 0 {
        errors.push("execution.max_iterations must be greater than 0".to_string());
    }

    // Validate max_parallel_agents
    if let Some(agents) = config.execution.max_parallel_agents {
        if !(1..=10).contains(&agents) {
            errors.push(
                "execution.max_parallel_agents must be an integer between 1 and 10".to_string(),
            );
        }
    }

    // Validate worktree_path
    if let Some(ref path) = config.execution.worktree_path {
        if path.trim().is_empty() {
            errors.push("execution.worktree_path cannot be empty".to_string());
        }
    }

    // Validate base_branch
    if let Some(ref branch) = config.execution.base_branch {
        if branch.trim().is_empty() {
            errors.push("execution.base_branch cannot be empty".to_string());
        }
    }

    // Validate Jira config when backend is jira
    if config.backend == Backend::Jira {
        validate_jira_config(config, &mut errors);
    }

    // Validate verification config if present
    if let Some(ref verification) = config.execution.verification {
        validate_verification_config(verification, &mut errors);
    }

    ValidationResult {
        valid: errors.is_empty(),
        errors,
    }
}

fn validate_jira_config(config: &LoopConfig, errors: &mut Vec<String>) {
    match &config.jira {
        None => {
            errors.push("jira configuration is required when backend is jira".to_string());
        }
        Some(jira) => {
            validate_jira_fields(jira, errors);
        }
    }
}

fn validate_jira_fields(jira: &JiraConfig, errors: &mut Vec<String>) {
    match &jira.base_url {
        None => {
            errors.push("jira.base_url is required when backend is jira".to_string());
        }
        Some(url) => {
            if !url.starts_with("https://") {
                errors.push("jira.base_url must be an HTTPS URL".to_string());
            }
        }
    }

    match &jira.project_key {
        None => {
            errors.push("jira.project_key is required when backend is jira".to_string());
        }
        Some(key) => {
            if !key.chars().all(|c| c.is_ascii_uppercase()) {
                errors.push("jira.project_key must be uppercase letters only".to_string());
            }
        }
    }
}

fn validate_verification_config(
    verification: &crate::types::config::VerificationConfig,
    errors: &mut Vec<String>,
) {
    if verification.coverage_threshold > 100 {
        errors.push(
            "execution.verification.coverage_threshold must be between 0 and 100".to_string(),
        );
    }

    if verification.max_rework_iterations < 1 || verification.max_rework_iterations > 10 {
        errors.push(
            "execution.verification.max_rework_iterations must be between 1 and 10".to_string(),
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_read_config_missing_file_returns_defaults() {
        let config = read_config("/nonexistent/path/config.yaml").unwrap();
        assert_eq!(config.backend, Backend::Linear);
        assert_eq!(config.execution.delay_seconds, 3);
        assert_eq!(config.execution.max_iterations, 50);
        assert_eq!(config.execution.model, Model::Opus);
    }

    #[test]
    fn test_read_config_parses_yaml() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");
        let yaml = r#"
backend: jira
execution:
  delay_seconds: 5
  max_iterations: 100
  model: sonnet
  sandbox: false
jira:
  base_url: "https://example.atlassian.net"
  project_key: "PROJ"
"#;
        std::fs::write(&config_path, yaml).unwrap();

        let config = read_config(config_path.to_str().unwrap()).unwrap();
        assert_eq!(config.backend, Backend::Jira);
        assert_eq!(config.execution.delay_seconds, 5);
        assert_eq!(config.execution.max_iterations, 100);
        assert_eq!(config.execution.model, Model::Sonnet);
        assert!(!config.execution.sandbox);
        assert!(config.jira.is_some());
        let jira = config.jira.unwrap();
        assert_eq!(jira.base_url, Some("https://example.atlassian.net".to_string()));
        assert_eq!(jira.project_key, Some("PROJ".to_string()));
    }

    #[test]
    fn test_read_config_merges_with_defaults() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");
        // Only override backend, rest should be defaults
        let yaml = "backend: local\n";
        std::fs::write(&config_path, yaml).unwrap();

        let config = read_config(config_path.to_str().unwrap()).unwrap();
        assert_eq!(config.backend, Backend::Local);
        // These should be defaults via serde(default)
        assert_eq!(config.execution.delay_seconds, 3);
        assert_eq!(config.execution.max_iterations, 50);
        assert_eq!(config.execution.model, Model::Opus);
    }

    #[test]
    fn test_read_config_with_env_overrides() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");
        std::fs::write(&config_path, "backend: linear\n").unwrap();

        // Set env vars
        env::set_var("MOBIUS_MODEL", "sonnet");
        env::set_var("MOBIUS_DELAY_SECONDS", "10");

        let config = read_config_with_env(config_path.to_str().unwrap()).unwrap();
        assert_eq!(config.execution.model, Model::Sonnet);
        assert_eq!(config.execution.delay_seconds, 10);

        // Clean up
        env::remove_var("MOBIUS_MODEL");
        env::remove_var("MOBIUS_DELAY_SECONDS");
    }

    #[test]
    fn test_read_config_with_env_backend_override() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");
        std::fs::write(&config_path, "backend: linear\n").unwrap();

        env::set_var("MOBIUS_BACKEND", "local");
        let config = read_config_with_env(config_path.to_str().unwrap()).unwrap();
        assert_eq!(config.backend, Backend::Local);
        env::remove_var("MOBIUS_BACKEND");
    }

    #[test]
    fn test_read_config_with_env_sandbox_override() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");
        std::fs::write(&config_path, "backend: linear\n").unwrap();

        env::set_var("MOBIUS_SANDBOX_ENABLED", "false");
        let config = read_config_with_env(config_path.to_str().unwrap()).unwrap();
        assert!(!config.execution.sandbox);
        env::remove_var("MOBIUS_SANDBOX_ENABLED");
    }

    #[test]
    fn test_write_config_creates_file() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("sub").join("config.yaml");
        let config = LoopConfig::default();

        write_config(config_path.to_str().unwrap(), &config).unwrap();
        assert!(config_path.exists());

        let content = std::fs::read_to_string(&config_path).unwrap();
        assert!(content.contains("# Mobius Configuration"));
        assert!(content.contains("backend"));
    }

    #[test]
    fn test_write_config_roundtrip() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");
        let config = LoopConfig::default();

        write_config(config_path.to_str().unwrap(), &config).unwrap();
        let reloaded = read_config(config_path.to_str().unwrap()).unwrap();

        assert_eq!(reloaded.backend, config.backend);
        assert_eq!(reloaded.execution.delay_seconds, config.execution.delay_seconds);
        assert_eq!(reloaded.execution.model, config.execution.model);
    }

    #[test]
    fn test_config_exists() {
        let tmp = tempfile::tempdir().unwrap();
        let config_path = tmp.path().join("config.yaml");

        assert!(!config_exists(config_path.to_str().unwrap()));
        std::fs::write(&config_path, "backend: linear\n").unwrap();
        assert!(config_exists(config_path.to_str().unwrap()));
    }

    #[test]
    fn test_validate_config_valid_default() {
        let config = LoopConfig::default();
        let result = validate_config(&config);
        assert!(result.valid, "Default config should be valid: {:?}", result.errors);
    }

    #[test]
    fn test_validate_config_invalid_parallel_agents() {
        let mut config = LoopConfig::default();
        config.execution.max_parallel_agents = Some(0);
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("max_parallel_agents")));

        config.execution.max_parallel_agents = Some(11);
        let result = validate_config(&config);
        assert!(!result.valid);
    }

    #[test]
    fn test_validate_config_empty_worktree_path() {
        let mut config = LoopConfig::default();
        config.execution.worktree_path = Some("  ".to_string());
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("worktree_path")));
    }

    #[test]
    fn test_validate_config_empty_base_branch() {
        let mut config = LoopConfig::default();
        config.execution.base_branch = Some("".to_string());
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("base_branch")));
    }

    #[test]
    fn test_validate_config_jira_requires_base_url() {
        let mut config = LoopConfig::default();
        config.backend = Backend::Jira;
        config.jira = Some(JiraConfig {
            base_url: None,
            project_key: Some("PROJ".to_string()),
            ..Default::default()
        });
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("base_url")));
    }

    #[test]
    fn test_validate_config_jira_requires_https() {
        let mut config = LoopConfig::default();
        config.backend = Backend::Jira;
        config.jira = Some(JiraConfig {
            base_url: Some("http://example.com".to_string()),
            project_key: Some("PROJ".to_string()),
            ..Default::default()
        });
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("HTTPS")));
    }

    #[test]
    fn test_validate_config_jira_project_key_uppercase() {
        let mut config = LoopConfig::default();
        config.backend = Backend::Jira;
        config.jira = Some(JiraConfig {
            base_url: Some("https://example.atlassian.net".to_string()),
            project_key: Some("proj".to_string()),
            ..Default::default()
        });
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("uppercase")));
    }

    #[test]
    fn test_validate_config_verification_threshold() {
        let mut config = LoopConfig::default();
        config.execution.verification = Some(crate::types::config::VerificationConfig {
            coverage_threshold: 101,
            ..Default::default()
        });
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("coverage_threshold")));
    }

    #[test]
    fn test_validate_config_verification_rework_iterations() {
        let mut config = LoopConfig::default();
        config.execution.verification = Some(crate::types::config::VerificationConfig {
            max_rework_iterations: 0,
            ..Default::default()
        });
        let result = validate_config(&config);
        assert!(!result.valid);
        assert!(result.errors.iter().any(|e| e.contains("max_rework_iterations")));
    }
}
