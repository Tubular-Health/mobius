import { cpSync, existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { parse, stringify } from 'yaml';
import type { LoopConfig, PathConfig } from '../types.js';
import { DEFAULT_CONFIG } from '../types.js';
import {
  getAgentsTemplatePath,
  getBundledCommandsDir,
  getBundledSkillsDir,
  getDefaultConfigPath,
  getGlobalCommandsDir,
} from './paths.js';

/**
 * Read and parse config file, merging with defaults
 */
export function readConfig(configPath: string): LoopConfig {
  if (!existsSync(configPath)) {
    return { ...DEFAULT_CONFIG };
  }

  try {
    const content = readFileSync(configPath, 'utf-8');
    const parsed = parse(content) as Partial<LoopConfig>;

    // Deep merge with defaults
    return {
      backend: parsed.backend ?? DEFAULT_CONFIG.backend,
      linear: parsed.linear,
      jira: parsed.jira,
      execution: {
        ...DEFAULT_CONFIG.execution,
        ...parsed.execution,
      },
    };
  } catch {
    return { ...DEFAULT_CONFIG };
  }
}

/**
 * Write config to file
 */
export function writeConfig(configPath: string, config: LoopConfig): void {
  const dir = dirname(configPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  const content = `# Loop Configuration
# Generated by 'loop setup'
#
# Environment variables override these settings:
#   ISSUE_LOOP_BACKEND, ISSUE_LOOP_DELAY_SECONDS, etc.

${stringify(config)}`;

  writeFileSync(configPath, content, 'utf-8');
}

/**
 * Copy skills from package to target directory
 */
export function copySkills(targetDir: string): void {
  const bundledDir = getBundledSkillsDir();

  if (!existsSync(bundledDir)) {
    throw new Error(`Bundled skills not found at ${bundledDir}`);
  }

  if (!existsSync(targetDir)) {
    mkdirSync(targetDir, { recursive: true });
  }

  // Copy each skill directory
  cpSync(bundledDir, targetDir, { recursive: true });
}

/**
 * Copy commands from package to target directory
 */
export function copyCommands(paths: PathConfig): void {
  const bundledDir = getBundledCommandsDir();

  if (!existsSync(bundledDir)) {
    // Commands are optional
    return;
  }

  const targetDir =
    paths.type === 'local'
      ? join(dirname(paths.configPath), '.claude', 'commands')
      : getGlobalCommandsDir();

  if (!existsSync(targetDir)) {
    mkdirSync(targetDir, { recursive: true });
  }

  cpSync(bundledDir, targetDir, { recursive: true });
}

/**
 * Copy AGENTS.md template to project
 */
export function copyAgentsTemplate(targetDir: string): void {
  const templatePath = getAgentsTemplatePath();
  const targetPath = join(targetDir, 'AGENTS.md');

  if (!existsSync(templatePath)) {
    return;
  }

  // Only copy if target doesn't exist
  if (!existsSync(targetPath)) {
    const content = readFileSync(templatePath, 'utf-8');
    writeFileSync(targetPath, content, 'utf-8');
  }
}

/**
 * Copy default config as template
 */
export function copyDefaultConfig(targetPath: string): void {
  const defaultPath = getDefaultConfigPath();

  if (!existsSync(defaultPath)) {
    // Create from DEFAULT_CONFIG if template missing
    writeConfig(targetPath, DEFAULT_CONFIG);
    return;
  }

  const dir = dirname(targetPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  const content = readFileSync(defaultPath, 'utf-8');
  writeFileSync(targetPath, content, 'utf-8');
}

/**
 * Ensure .claude/settings.json has .mobius/ permissions
 */
export function ensureClaudeSettings(projectDir: string): void {
  const settingsPath = join(projectDir, '.claude', 'settings.json');
  const mobiusPermissions = [
    'Bash(mkdir */.mobius/*)',
    'Bash(mkdir -p */.mobius/*)',
    'Bash(mkdir .mobius/*)',
    'Bash(mkdir -p .mobius/*)',
    'Bash(ls .mobius/*)',
    'Bash(ls */.mobius/*)',
    'Write(.mobius/**)',
    'Edit(.mobius/**)',
  ];

  let settings: { permissions?: { allow?: string[] } } = {};

  if (existsSync(settingsPath)) {
    try {
      settings = JSON.parse(readFileSync(settingsPath, 'utf-8'));
    } catch {
      // If parse fails, start fresh
      settings = {};
    }
  }

  if (!settings.permissions) {
    settings.permissions = {};
  }
  if (!settings.permissions.allow) {
    settings.permissions.allow = [];
  }

  // Add missing permissions
  let added = 0;
  for (const perm of mobiusPermissions) {
    if (!settings.permissions.allow.includes(perm)) {
      settings.permissions.allow.push(perm);
      added++;
    }
  }

  if (added > 0) {
    const dir = dirname(settingsPath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    writeFileSync(settingsPath, `${JSON.stringify(settings, null, 2)}\n`, 'utf-8');
  }
}

/**
 * Check if config exists
 */
export function configExists(configPath: string): boolean {
  return existsSync(configPath);
}

/**
 * Validate verification quality gate configuration
 */
function validateVerificationConfig(config: LoopConfig): string[] {
  const errors: string[] = [];
  const verification = config.execution?.verification;

  // Only validate if verification config is defined
  if (verification === undefined) {
    return errors;
  }

  // Validate coverage_threshold: must be a number between 0 and 100
  if (verification.coverage_threshold !== undefined) {
    if (
      typeof verification.coverage_threshold !== 'number' ||
      verification.coverage_threshold < 0 ||
      verification.coverage_threshold > 100
    ) {
      errors.push('execution.verification.coverage_threshold must be a number between 0 and 100');
    }
  }

  // Validate require_all_tests_pass: must be a boolean
  if (verification.require_all_tests_pass !== undefined) {
    if (typeof verification.require_all_tests_pass !== 'boolean') {
      errors.push('execution.verification.require_all_tests_pass must be a boolean');
    }
  }

  // Validate performance_check: must be a boolean
  if (verification.performance_check !== undefined) {
    if (typeof verification.performance_check !== 'boolean') {
      errors.push('execution.verification.performance_check must be a boolean');
    }
  }

  // Validate security_check: must be a boolean
  if (verification.security_check !== undefined) {
    if (typeof verification.security_check !== 'boolean') {
      errors.push('execution.verification.security_check must be a boolean');
    }
  }

  // Validate max_rework_iterations: must be an integer between 1 and 10
  if (verification.max_rework_iterations !== undefined) {
    if (
      typeof verification.max_rework_iterations !== 'number' ||
      !Number.isInteger(verification.max_rework_iterations) ||
      verification.max_rework_iterations < 1 ||
      verification.max_rework_iterations > 10
    ) {
      errors.push(
        'execution.verification.max_rework_iterations must be an integer between 1 and 10'
      );
    }
  }

  return errors;
}

/**
 * Validate Jira-specific configuration
 */
function validateJiraConfig(config: LoopConfig): string[] {
  const errors: string[] = [];

  if (config.backend === 'jira') {
    if (!config.jira?.base_url) {
      errors.push('jira.base_url is required when backend is jira');
    } else if (!config.jira.base_url.startsWith('https://')) {
      errors.push('jira.base_url must be an HTTPS URL');
    }

    if (!config.jira?.project_key) {
      errors.push('jira.project_key is required when backend is jira');
    } else if (!/^[A-Z]+$/.test(config.jira.project_key)) {
      errors.push('jira.project_key must be uppercase letters only');
    }

    if (config.jira?.auth_method && !['api_token', 'oauth'].includes(config.jira.auth_method)) {
      errors.push('jira.auth_method must be "api_token" or "oauth"');
    }
  }

  return errors;
}

/**
 * Validate config structure
 */
export function validateConfig(config: LoopConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!config.backend) {
    errors.push('Missing required field: backend');
  } else if (!['linear', 'jira', 'local'].includes(config.backend)) {
    errors.push(`Invalid backend: ${config.backend}. Must be 'linear', 'jira', or 'local'`);
  }

  if (!config.execution) {
    errors.push('Missing required section: execution');
  } else {
    if (typeof config.execution.delay_seconds !== 'number' || config.execution.delay_seconds < 0) {
      errors.push('execution.delay_seconds must be a non-negative number');
    }
    if (
      typeof config.execution.max_iterations !== 'number' ||
      config.execution.max_iterations < 0
    ) {
      errors.push('execution.max_iterations must be a non-negative number');
    }
    if (!['opus', 'sonnet', 'haiku'].includes(config.execution.model)) {
      errors.push(`Invalid model: ${config.execution.model}. Must be 'opus', 'sonnet', or 'haiku'`);
    }

    // Validate parallel execution and worktree options (optional fields)
    if (config.execution.max_parallel_agents !== undefined) {
      if (
        typeof config.execution.max_parallel_agents !== 'number' ||
        !Number.isInteger(config.execution.max_parallel_agents) ||
        config.execution.max_parallel_agents < 1 ||
        config.execution.max_parallel_agents > 10
      ) {
        errors.push('execution.max_parallel_agents must be an integer between 1 and 10');
      }
    }

    if (config.execution.worktree_path !== undefined) {
      if (typeof config.execution.worktree_path !== 'string') {
        errors.push('execution.worktree_path must be a string');
      } else if (config.execution.worktree_path.trim() === '') {
        errors.push('execution.worktree_path cannot be empty');
      }
      // Note: <repo> placeholder is valid and will be replaced at runtime
    }

    if (config.execution.cleanup_on_success !== undefined) {
      if (typeof config.execution.cleanup_on_success !== 'boolean') {
        errors.push('execution.cleanup_on_success must be a boolean (true or false)');
      }
    }

    if (config.execution.base_branch !== undefined) {
      if (typeof config.execution.base_branch !== 'string') {
        errors.push('execution.base_branch must be a string');
      } else if (config.execution.base_branch.trim() === '') {
        errors.push('execution.base_branch cannot be empty');
      }
    }
  }

  // Validate Jira configuration when backend is 'jira'
  errors.push(...validateJiraConfig(config));

  // Validate verification quality gate configuration (if defined)
  errors.push(...validateVerificationConfig(config));

  return { valid: errors.length === 0, errors };
}
