import { existsSync, mkdirSync, readFileSync, writeFileSync, cpSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { parse, stringify } from 'yaml';
import type { LoopConfig, PathConfig } from '../types.js';
import { DEFAULT_CONFIG } from '../types.js';
import {
  getBundledSkillsDir,
  getBundledCommandsDir,
  getDefaultConfigPath,
  getAgentsTemplatePath,
  getGlobalCommandsDir,
} from './paths.js';

/**
 * Read and parse config file, merging with defaults
 */
export function readConfig(configPath: string): LoopConfig {
  if (!existsSync(configPath)) {
    return { ...DEFAULT_CONFIG };
  }

  try {
    const content = readFileSync(configPath, 'utf-8');
    const parsed = parse(content) as Partial<LoopConfig>;

    // Deep merge with defaults
    return {
      backend: parsed.backend ?? DEFAULT_CONFIG.backend,
      linear: parsed.linear,
      jira: parsed.jira,
      execution: {
        ...DEFAULT_CONFIG.execution,
        ...parsed.execution,
      },
    };
  } catch {
    return { ...DEFAULT_CONFIG };
  }
}

/**
 * Write config to file
 */
export function writeConfig(configPath: string, config: LoopConfig): void {
  const dir = dirname(configPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  const content = `# Loop Configuration
# Generated by 'loop setup'
#
# Environment variables override these settings:
#   ISSUE_LOOP_BACKEND, ISSUE_LOOP_DELAY_SECONDS, etc.

${stringify(config)}`;

  writeFileSync(configPath, content, 'utf-8');
}

/**
 * Copy skills from package to target directory
 */
export function copySkills(targetDir: string): void {
  const bundledDir = getBundledSkillsDir();

  if (!existsSync(bundledDir)) {
    throw new Error(`Bundled skills not found at ${bundledDir}`);
  }

  if (!existsSync(targetDir)) {
    mkdirSync(targetDir, { recursive: true });
  }

  // Copy each skill directory
  cpSync(bundledDir, targetDir, { recursive: true });
}

/**
 * Copy commands from package to target directory
 */
export function copyCommands(paths: PathConfig): void {
  const bundledDir = getBundledCommandsDir();

  if (!existsSync(bundledDir)) {
    // Commands are optional
    return;
  }

  const targetDir =
    paths.type === 'local'
      ? join(dirname(paths.configPath), '.claude', 'commands')
      : getGlobalCommandsDir();

  if (!existsSync(targetDir)) {
    mkdirSync(targetDir, { recursive: true });
  }

  cpSync(bundledDir, targetDir, { recursive: true });
}

/**
 * Copy AGENTS.md template to project
 */
export function copyAgentsTemplate(targetDir: string): void {
  const templatePath = getAgentsTemplatePath();
  const targetPath = join(targetDir, 'AGENTS.md');

  if (!existsSync(templatePath)) {
    return;
  }

  // Only copy if target doesn't exist
  if (!existsSync(targetPath)) {
    const content = readFileSync(templatePath, 'utf-8');
    writeFileSync(targetPath, content, 'utf-8');
  }
}

/**
 * Copy default config as template
 */
export function copyDefaultConfig(targetPath: string): void {
  const defaultPath = getDefaultConfigPath();

  if (!existsSync(defaultPath)) {
    // Create from DEFAULT_CONFIG if template missing
    writeConfig(targetPath, DEFAULT_CONFIG);
    return;
  }

  const dir = dirname(targetPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  const content = readFileSync(defaultPath, 'utf-8');
  writeFileSync(targetPath, content, 'utf-8');
}

/**
 * Check if config exists
 */
export function configExists(configPath: string): boolean {
  return existsSync(configPath);
}

/**
 * Validate config structure
 */
export function validateConfig(config: LoopConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!config.backend) {
    errors.push('Missing required field: backend');
  } else if (!['linear', 'jira'].includes(config.backend)) {
    errors.push(`Invalid backend: ${config.backend}. Must be 'linear' or 'jira'`);
  }

  if (!config.execution) {
    errors.push('Missing required section: execution');
  } else {
    if (typeof config.execution.delay_seconds !== 'number' || config.execution.delay_seconds < 0) {
      errors.push('execution.delay_seconds must be a non-negative number');
    }
    if (
      typeof config.execution.max_iterations !== 'number' ||
      config.execution.max_iterations < 0
    ) {
      errors.push('execution.max_iterations must be a non-negative number');
    }
    if (!['opus', 'sonnet', 'haiku'].includes(config.execution.model)) {
      errors.push(`Invalid model: ${config.execution.model}. Must be 'opus', 'sonnet', or 'haiku'`);
    }

    // Validate parallel execution and worktree options (optional fields)
    if (config.execution.max_parallel_agents !== undefined) {
      if (
        typeof config.execution.max_parallel_agents !== 'number' ||
        !Number.isInteger(config.execution.max_parallel_agents) ||
        config.execution.max_parallel_agents < 1 ||
        config.execution.max_parallel_agents > 10
      ) {
        errors.push('execution.max_parallel_agents must be an integer between 1 and 10');
      }
    }

    if (config.execution.worktree_path !== undefined) {
      if (typeof config.execution.worktree_path !== 'string') {
        errors.push('execution.worktree_path must be a string');
      } else if (config.execution.worktree_path.trim() === '') {
        errors.push('execution.worktree_path cannot be empty');
      }
      // Note: <repo> placeholder is valid and will be replaced at runtime
    }

    if (config.execution.cleanup_on_success !== undefined) {
      if (typeof config.execution.cleanup_on_success !== 'boolean') {
        errors.push('execution.cleanup_on_success must be a boolean (true or false)');
      }
    }

    if (config.execution.base_branch !== undefined) {
      if (typeof config.execution.base_branch !== 'string') {
        errors.push('execution.base_branch must be a string');
      } else if (config.execution.base_branch.trim() === '') {
        errors.push('execution.base_branch cannot be empty');
      }
    }
  }

  return { valid: errors.length === 0, errors };
}
